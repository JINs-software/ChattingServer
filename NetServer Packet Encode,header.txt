
- 1 byte 고정 Key 
- 1 byte 랜덤 Key

키는 2 개를 사용합니다. 
고정키는 상호간에 정해진 상수값 상태이며, 랜덤키는 패킷 헤더에 첨부 됩니다.

Code(1byte) - Len(2byte) - RandKey(1byte) - CheckSum(1byte) - Payload(Len byte)

@ 암호화 대상은 CheckSum + Payload 입니다.  Len 과 RandKey 는 암호화 하지 않고 그대로 노출 합니다.

@ Len 은 메시지의 길이  판단용 이므로 Len 이 암호화가 되면 메시지 길이조차 확인이 안됩니다.


@ CheckSum

Payload 부분을 1byte 씩 모두 더해서 % 256 한 unsigned char 값

체크섬은 디코딩의 성공 여부로서 판단 합니다.  비트연산을 통한 디코딩을 하기 때문에 디코딩에 실패 여부를 알지 못합니다.
잘못된 키로 잘못된 디코딩이 되어도 그냥 디코딩이 될  뿐입니다.  결과의 성공여부 판단을 할 방법이 없다는 것이지요.

그래서 수신후 디코딩 뒤에 체크섬을 생성 비교하여 체크섬이 일치 한다면 디코딩 성공으로 판단하며,
체크섬이 틀렸다면 디코딩 실패로 판단 할 것입니다.




모든 데이터는 unsigned char 로 처리 합니다.

1. 키의 용량이 적어야 한다. (속도저하, 가벼운 암호화 목적)
2. 패킷 생성시 마다 키가 변경되게 하고 싶다 - 같은 패킷이라도 항상 다른 결과가 나오도록
3. 데이터에 패턴이 있더라도 암호화 결과에는 패턴이 나타나지 않아야 한다.
4. 키를 잘못 입력하면 잘못된 결과가 나와야 한다.


상호 고정키 1Byte - K   (클라 - 서버 쌍방의 상수값)
공개 랜덤키 1Byte - RK  (클라 - 서버 송수신 패킷 헤더에 포함)


# 원본 데이터 바이트 단위  D1 D2 D3 D4
----------------------------------------------------------------------------------------------------------
|          D1           |            D2             |            D3             |             D4            |
----------------------------------------------------------------------------------------------------------
   D1 ^ (RK + 1) = P1   |  D2 ^ (P1 + RK + 2) = P2  |  D3 ^ (P2 + RK + 3) = P3  |  D4 ^ (P3 + RK + 4) = P4  |
    P1 ^ (K + 1) = E1   |   P2 ^ (E1 + K + 2) = E2  |   P3 ^ (E2 + K + 3) = E3  |   P4 ^ (E3 + K + 4) = E4  |

# 암호 데이터 바이트 단위  E1 E2 E3 E4
----------------------------------------------------------------------------------------------------------
	      E1                      E2                          E3                           E4 
----------------------------------------------------------------------------------------------------------

1. 키의 용량이 적어야한다 - 무작위 대입법에 약하지만 이는 무시 함
2. 패킷 생성시마다 랜덤키 1개를 생성하여 이를 그대로 패킷에 포함하여 전달 할 것임. 이는 패킷마다 모양을 다르게 하기 위함
3. 0 0 0 0 0  같은 데이터가 반복 되더라도 이 패턴이 나타나지 않도록 하기 위해 byte 단위로 +2,+3,+4 를 해주고 있음
4. 각 위치마다의 ^ 대상에 RKey, Key 를 반영하여 잘못된 키가 들어올때 잘못된 결과를 유도함.


-- sample data --

위 방법대로 암호화된 샘플 데이터, 이와 같은 결과가 나오는지 그리고 복호화가 잘 되는지 확인 합니다.


사이즈 : 55byte

데이터 (텍스트) : aaaaaaaaaabbbbbbbbbbcccccccccc1234567890abcdefghijklmn  (널문자포함 55byte)
데이터 (16진수) : 61 61 61 61 61 61 61 61 61 61 62 62 62 62 62 62 62 62 62 62 63 63 63 63 63 63 63 63 63 63 31 32 33 34 35 36 37 38 39 30 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 00

고정키 : 0xa9
랜덤키 : 0x31

암호화 (16진수) : f9 43 95 8c 5f f3 f7 44 b1 87 46 23 ad b5 1e 01 c1 a3 1e 3f b4 80 18 1b b2 ac 36 0b 8c 9c 4a 5e 84 84 7a 0e 74 84 72 0c 16 a8 82 68 c6 ac 72 74 86 20 32 50 86 04 2d


